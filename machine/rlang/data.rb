# Memory 0 to 64: store static data
#
# Offsets below are relative to the Call Frame structure
DAta.current_address = 0
# Malloc static data (see malloc.wat)
DAta[:ptr]    = 0  # base header for free empty list (ptr)
DAta[:size]   = 0  # base header for free empty list (size) 
DAta[:free_p] = 0  # Malloc free list pointer (Header *freep)

# *** This file is generated by insn_generator_rlang.rb ***

# ========== Rubinius Instruction Set ================
#
# Instructions
#    -> Instruction names
DAta.align(4)
DAta[:name_add_scope] = "add_scope\x00"
DAta[:name_allow_private] = "allow_private\x00"
DAta[:name_cast_array] = "cast_array\x00"
DAta[:name_cast_for_multi_block_arg] = "cast_for_multi_block_arg\x00"
DAta[:name_cast_for_single_block_arg] = "cast_for_single_block_arg\x00"
DAta[:name_cast_for_splat_block_arg] = "cast_for_splat_block_arg\x00"
DAta[:name_cast_multi_value] = "cast_multi_value\x00"
DAta[:name_check_frozen] = "check_frozen\x00"
DAta[:name_check_interrupts] = "check_interrupts\x00"
DAta[:name_check_serial] = "check_serial\x00"
DAta[:name_check_serial_private] = "check_serial_private\x00"
DAta[:name_clear_exception] = "clear_exception\x00"
DAta[:name_create_block] = "create_block\x00"
DAta[:name_dup] = "dup\x00"
DAta[:name_dup_many] = "dup_many\x00"
DAta[:name_ensure_return] = "ensure_return\x00"
DAta[:name_find_const] = "find_const\x00"
DAta[:name_goto] = "goto\x00"
DAta[:name_goto_if_equal] = "goto_if_equal\x00"
DAta[:name_goto_if_false] = "goto_if_false\x00"
DAta[:name_goto_if_nil] = "goto_if_nil\x00"
DAta[:name_goto_if_not_equal] = "goto_if_not_equal\x00"
DAta[:name_goto_if_not_nil] = "goto_if_not_nil\x00"
DAta[:name_goto_if_not_undefined] = "goto_if_not_undefined\x00"
DAta[:name_goto_if_true] = "goto_if_true\x00"
DAta[:name_goto_if_undefined] = "goto_if_undefined\x00"
DAta[:name_instance_of] = "instance_of\x00"
DAta[:name_invoke_primitive] = "invoke_primitive\x00"
DAta[:name_kind_of] = "kind_of\x00"
DAta[:name_make_array] = "make_array\x00"
DAta[:name_move_down] = "move_down\x00"
DAta[:name_noop] = "noop\x00"
DAta[:name_object_to_s] = "object_to_s\x00"
DAta[:name_passed_arg] = "passed_arg\x00"
DAta[:name_passed_blockarg] = "passed_blockarg\x00"
DAta[:name_pop] = "pop\x00"
DAta[:name_pop_many] = "pop_many\x00"
DAta[:name_pop_unwind] = "pop_unwind\x00"
DAta[:name_push_block] = "push_block\x00"
DAta[:name_push_block_arg] = "push_block_arg\x00"
DAta[:name_push_const] = "push_const\x00"
DAta[:name_push_cpath_top] = "push_cpath_top\x00"
DAta[:name_push_current_exception] = "push_current_exception\x00"
DAta[:name_push_exception_state] = "push_exception_state\x00"
DAta[:name_push_false] = "push_false\x00"
DAta[:name_push_has_block] = "push_has_block\x00"
DAta[:name_push_int] = "push_int\x00"
DAta[:name_push_ivar] = "push_ivar\x00"
DAta[:name_push_literal] = "push_literal\x00"
DAta[:name_push_local] = "push_local\x00"
DAta[:name_push_local_depth] = "push_local_depth\x00"
DAta[:name_push_memo] = "push_memo\x00"
DAta[:name_push_mirror] = "push_mirror\x00"
DAta[:name_push_my_field] = "push_my_field\x00"
DAta[:name_push_my_offset] = "push_my_offset\x00"
DAta[:name_push_nil] = "push_nil\x00"
DAta[:name_push_proc] = "push_proc\x00"
DAta[:name_push_rubinius] = "push_rubinius\x00"
DAta[:name_push_scope] = "push_scope\x00"
DAta[:name_push_self] = "push_self\x00"
DAta[:name_push_stack_local] = "push_stack_local\x00"
DAta[:name_push_true] = "push_true\x00"
DAta[:name_push_type] = "push_type\x00"
DAta[:name_push_undef] = "push_undef\x00"
DAta[:name_push_variables] = "push_variables\x00"
DAta[:name_raise_break] = "raise_break\x00"
DAta[:name_raise_exc] = "raise_exc\x00"
DAta[:name_raise_return] = "raise_return\x00"
DAta[:name_reraise] = "reraise\x00"
DAta[:name_restore_exception_state] = "restore_exception_state\x00"
DAta[:name_ret] = "ret\x00"
DAta[:name_rotate] = "rotate\x00"
DAta[:name_send_method] = "send_method\x00"
DAta[:name_send_stack] = "send_stack\x00"
DAta[:name_send_stack_with_block] = "send_stack_with_block\x00"
DAta[:name_send_stack_with_splat] = "send_stack_with_splat\x00"
DAta[:name_send_super_stack_with_block] = "send_super_stack_with_block\x00"
DAta[:name_send_super_stack_with_splat] = "send_super_stack_with_splat\x00"
DAta[:name_send_vcall] = "send_vcall\x00"
DAta[:name_set_call_flags] = "set_call_flags\x00"
DAta[:name_set_const] = "set_const\x00"
DAta[:name_set_const_at] = "set_const_at\x00"
DAta[:name_set_ivar] = "set_ivar\x00"
DAta[:name_set_local] = "set_local\x00"
DAta[:name_set_local_depth] = "set_local_depth\x00"
DAta[:name_set_stack_local] = "set_stack_local\x00"
DAta[:name_setup_unwind] = "setup_unwind\x00"
DAta[:name_shift_array] = "shift_array\x00"
DAta[:name_store_my_field] = "store_my_field\x00"
DAta[:name_string_append] = "string_append\x00"
DAta[:name_string_build] = "string_build\x00"
DAta[:name_string_dup] = "string_dup\x00"
DAta[:name_swap] = "swap\x00"
DAta[:name_unwind] = "unwind\x00"
DAta[:name_yield_debugger] = "yield_debugger\x00"
DAta[:name_yield_splat] = "yield_splat\x00"
DAta[:name_yield_stack] = "yield_stack\x00"
DAta[:name_zsuper] = "zsuper\x00"
DAta[:name_push_file] = "push_file\x00"
DAta[:name_p_any] = "p_any\x00"
DAta[:name_p_call] = "p_call\x00"
DAta[:name_p_char] = "p_char\x00"
DAta[:name_p_char_set] = "p_char_set\x00"
DAta[:name_p_choice] = "p_choice\x00"
DAta[:name_p_commit] = "p_commit\x00"
DAta[:name_p_commit_back] = "p_commit_back\x00"
DAta[:name_p_commit_partial] = "p_commit_partial\x00"
DAta[:name_p_end] = "p_end\x00"
DAta[:name_p_fail] = "p_fail\x00"
DAta[:name_p_fail_twice] = "p_fail_twice\x00"
DAta[:name_p_jump] = "p_jump\x00"
DAta[:name_p_return] = "p_return\x00"
DAta[:name_p_span] = "p_span\x00"
DAta[:name_p_test_any] = "p_test_any\x00"
DAta[:name_p_test_char] = "p_test_char\x00"
DAta[:name_p_test_char_set] = "p_test_char_set\x00"
DAta[:name_p_init] = "p_init\x00"
DAta[:name_m_bytes] = "m_bytes\x00"
DAta[:name_m_counter] = "m_counter\x00"
DAta[:name_m_sum] = "m_sum\x00"
DAta[:name_m_value] = "m_value\x00"
DAta[:name_m_time_stamp] = "m_time_stamp\x00"
DAta[:name_m_timer_start] = "m_timer_start\x00"
DAta[:name_m_timer_stop] = "m_timer_stop\x00"
DAta[:name_b_if_serial] = "b_if_serial\x00"
DAta[:name_b_if_int] = "b_if_int\x00"
DAta[:name_b_if] = "b_if\x00"
DAta[:name_r_load_local] = "r_load_local\x00"
DAta[:name_r_store_local] = "r_store_local\x00"
DAta[:name_r_load_local_depth] = "r_load_local_depth\x00"
DAta[:name_r_store_local_depth] = "r_store_local_depth\x00"
DAta[:name_r_load_stack] = "r_load_stack\x00"
DAta[:name_r_store_stack] = "r_store_stack\x00"
DAta[:name_r_load_literal] = "r_load_literal\x00"
DAta[:name_r_load_int] = "r_load_int\x00"
DAta[:name_r_store_int] = "r_store_int\x00"
DAta[:name_r_copy] = "r_copy\x00"
DAta[:name_n_iadd] = "n_iadd\x00"
DAta[:name_n_isub] = "n_isub\x00"
DAta[:name_n_imul] = "n_imul\x00"
DAta[:name_n_idiv] = "n_idiv\x00"
DAta[:name_n_iadd_o] = "n_iadd_o\x00"
DAta[:name_n_isub_o] = "n_isub_o\x00"
DAta[:name_n_imul_o] = "n_imul_o\x00"
DAta[:name_n_idiv_o] = "n_idiv_o\x00"
DAta[:name_n_ieq] = "n_ieq\x00"
DAta[:name_n_ine] = "n_ine\x00"
DAta[:name_n_ilt] = "n_ilt\x00"
DAta[:name_n_ile] = "n_ile\x00"
DAta[:name_n_igt] = "n_igt\x00"
DAta[:name_n_ige] = "n_ige\x00"
DAta[:name_n_ipopcnt] = "n_ipopcnt\x00"
DAta[:name_m_log] = "m_log\x00"
DAta[:name_m_debug] = "m_debug\x00"
DAta[:name_e_cache_method_p] = "e_cache_method_p\x00"
DAta[:name_e_cache_function_p] = "e_cache_function_p\x00"
DAta[:name_e_cache_value_p] = "e_cache_value_p\x00"
DAta[:name_e_cache_method] = "e_cache_method\x00"
DAta[:name_e_cache_function] = "e_cache_function\x00"
DAta[:name_e_cache_value] = "e_cache_value\x00"
DAta[:name_e_resolve_method] = "e_resolve_method\x00"
DAta[:name_e_resolve_receiver_method] = "e_resolve_receiver_method\x00"
DAta[:name_e_resolve_function] = "e_resolve_function\x00"
DAta[:name_e_resolve_scope_constant] = "e_resolve_scope_constant\x00"
DAta[:name_e_resolve_path_constant] = "e_resolve_path_constant\x00"
DAta[:name_e_signature] = "e_signature\x00"
DAta[:name_e_check_signature] = "e_check_signature\x00"
DAta[:name_e_invoke_method] = "e_invoke_method\x00"
DAta[:name_e_invoke_function] = "e_invoke_function\x00"
DAta[:name_a_instance] = "a_instance\x00"
DAta[:name_a_kind] = "a_kind\x00"
DAta[:name_a_method] = "a_method\x00"
DAta[:name_a_receiver_method] = "a_receiver_method\x00"
DAta[:name_a_type] = "a_type\x00"
DAta[:name_a_function] = "a_function\x00"
DAta[:name_a_equal] = "a_equal\x00"
DAta[:name_a_not_equal] = "a_not_equal\x00"
DAta[:name_a_less] = "a_less\x00"
DAta[:name_a_less_equal] = "a_less_equal\x00"
DAta[:name_a_greater] = "a_greater\x00"
DAta[:name_a_greater_equal] = "a_greater_equal\x00"
DAta[:name_goto_past] = "goto_past\x00"
DAta[:name_goto_future] = "goto_future\x00"
DAta[:name_r_load_0] = "r_load_0\x00"
DAta[:name_r_load_1] = "r_load_1\x00"
DAta[:name_r_load_nil] = "r_load_nil\x00"
DAta[:name_r_load_false] = "r_load_false\x00"
DAta[:name_r_load_true] = "r_load_true\x00"
DAta[:name_call_send] = "call_send\x00"
DAta[:name_call] = "call\x00"
DAta[:name_call_0] = "call_0\x00"
DAta[:name_push_tagged_nil] = "push_tagged_nil\x00"

#
#     Instruction Set
#
# An instruction is made of 5 fields
#   - Address of instruction name (i32)
#   - size of the instruction (i32)
#   - opcode id (i32)
#   - number of arguments  (i32)
#   - function pointer (actually WASM function index) (i32)
#-------
DAta.align(4)
DAta[:insn_data] = [
# add_scope 
DAta[:name_add_scope], 0, 0, 1, 0,
# allow_private 
DAta[:name_allow_private], 1, 0, 1, 1,
# cast_array 
DAta[:name_cast_array], 2, 0, 1, 2,
# cast_for_multi_block_arg 
DAta[:name_cast_for_multi_block_arg], 3, 0, 1, 3,
# cast_for_single_block_arg 
DAta[:name_cast_for_single_block_arg], 4, 0, 1, 4,
# cast_for_splat_block_arg 
DAta[:name_cast_for_splat_block_arg], 5, 0, 1, 5,
# cast_multi_value 
DAta[:name_cast_multi_value], 6, 0, 1, 6,
# check_frozen 
DAta[:name_check_frozen], 7, 0, 1, 7,
# check_interrupts 
DAta[:name_check_interrupts], 8, 0, 1, 8,
# check_serial literal, serial
DAta[:name_check_serial], 9, 2, 3, 9,
# check_serial_private literal, serial
DAta[:name_check_serial_private], 10, 2, 3, 10,
# clear_exception 
DAta[:name_clear_exception], 11, 0, 1, 11,
# create_block literal
DAta[:name_create_block], 12, 1, 2, 12,
# dup 
DAta[:name_dup], 13, 0, 1, 13,
# dup_many count
DAta[:name_dup_many], 14, 1, 2, 14,
# ensure_return 
DAta[:name_ensure_return], 15, 0, 1, 15,
# find_const literal
DAta[:name_find_const], 16, 1, 2, 16,
# goto location
DAta[:name_goto], 17, 1, 2, 17,
# goto_if_equal location
DAta[:name_goto_if_equal], 18, 1, 2, 18,
# goto_if_false location
DAta[:name_goto_if_false], 19, 1, 2, 19,
# goto_if_nil location
DAta[:name_goto_if_nil], 20, 1, 2, 20,
# goto_if_not_equal location
DAta[:name_goto_if_not_equal], 21, 1, 2, 21,
# goto_if_not_nil location
DAta[:name_goto_if_not_nil], 22, 1, 2, 22,
# goto_if_not_undefined location
DAta[:name_goto_if_not_undefined], 23, 1, 2, 23,
# goto_if_true location
DAta[:name_goto_if_true], 24, 1, 2, 24,
# goto_if_undefined location
DAta[:name_goto_if_undefined], 25, 1, 2, 25,
# instance_of 
DAta[:name_instance_of], 26, 0, 1, 26,
# invoke_primitive literal, count
DAta[:name_invoke_primitive], 27, 2, 3, 27,
# kind_of 
DAta[:name_kind_of], 28, 0, 1, 28,
# make_array count
DAta[:name_make_array], 29, 1, 2, 29,
# move_down positions
DAta[:name_move_down], 30, 1, 2, 30,
# noop 
DAta[:name_noop], 31, 0, 1, 31,
# object_to_s literal
DAta[:name_object_to_s], 32, 1, 2, 32,
# passed_arg index
DAta[:name_passed_arg], 33, 1, 2, 33,
# passed_blockarg count
DAta[:name_passed_blockarg], 34, 1, 2, 34,
# pop 
DAta[:name_pop], 35, 0, 1, 35,
# pop_many count
DAta[:name_pop_many], 36, 1, 2, 36,
# pop_unwind 
DAta[:name_pop_unwind], 37, 0, 1, 37,
# push_block 
DAta[:name_push_block], 38, 0, 1, 38,
# push_block_arg 
DAta[:name_push_block_arg], 39, 0, 1, 39,
# push_const literal
DAta[:name_push_const], 40, 1, 2, 40,
# push_cpath_top 
DAta[:name_push_cpath_top], 41, 0, 1, 41,
# push_current_exception 
DAta[:name_push_current_exception], 42, 0, 1, 42,
# push_exception_state 
DAta[:name_push_exception_state], 43, 0, 1, 43,
# push_false 
DAta[:name_push_false], 44, 0, 1, 44,
# push_has_block 
DAta[:name_push_has_block], 45, 0, 1, 45,
# push_int number
DAta[:name_push_int], 46, 1, 2, 46,
# push_ivar literal
DAta[:name_push_ivar], 47, 1, 2, 47,
# push_literal literal
DAta[:name_push_literal], 48, 1, 2, 48,
# push_local local
DAta[:name_push_local], 49, 1, 2, 49,
# push_local_depth depth, index
DAta[:name_push_local_depth], 50, 2, 3, 50,
# push_memo literal
DAta[:name_push_memo], 51, 1, 2, 51,
# push_mirror 
DAta[:name_push_mirror], 52, 0, 1, 52,
# push_my_field index
DAta[:name_push_my_field], 53, 1, 2, 53,
# push_my_offset index
DAta[:name_push_my_offset], 54, 1, 2, 54,
# push_nil 
DAta[:name_push_nil], 55, 0, 1, 55,
# push_proc 
DAta[:name_push_proc], 56, 0, 1, 56,
# push_rubinius 
DAta[:name_push_rubinius], 57, 0, 1, 57,
# push_scope 
DAta[:name_push_scope], 58, 0, 1, 58,
# push_self 
DAta[:name_push_self], 59, 0, 1, 59,
# push_stack_local which
DAta[:name_push_stack_local], 60, 1, 2, 60,
# push_true 
DAta[:name_push_true], 61, 0, 1, 61,
# push_type 
DAta[:name_push_type], 62, 0, 1, 62,
# push_undef 
DAta[:name_push_undef], 63, 0, 1, 63,
# push_variables 
DAta[:name_push_variables], 64, 0, 1, 64,
# raise_break 
DAta[:name_raise_break], 65, 0, 1, 65,
# raise_exc 
DAta[:name_raise_exc], 66, 0, 1, 66,
# raise_return 
DAta[:name_raise_return], 67, 0, 1, 67,
# reraise 
DAta[:name_reraise], 68, 0, 1, 68,
# restore_exception_state 
DAta[:name_restore_exception_state], 69, 0, 1, 69,
# ret index
DAta[:name_ret], 70, 1, 2, 70,
# rotate count
DAta[:name_rotate], 71, 1, 2, 71,
# send_method literal
DAta[:name_send_method], 72, 1, 2, 72,
# send_stack literal, count
DAta[:name_send_stack], 73, 2, 3, 73,
# send_stack_with_block literal, count
DAta[:name_send_stack_with_block], 74, 2, 3, 74,
# send_stack_with_splat literal, count
DAta[:name_send_stack_with_splat], 75, 2, 3, 75,
# send_super_stack_with_block literal, count
DAta[:name_send_super_stack_with_block], 76, 2, 3, 76,
# send_super_stack_with_splat literal, count
DAta[:name_send_super_stack_with_splat], 77, 2, 3, 77,
# send_vcall literal
DAta[:name_send_vcall], 78, 1, 2, 78,
# set_call_flags flags
DAta[:name_set_call_flags], 79, 1, 2, 79,
# set_const literal
DAta[:name_set_const], 80, 1, 2, 80,
# set_const_at literal
DAta[:name_set_const_at], 81, 1, 2, 81,
# set_ivar literal
DAta[:name_set_ivar], 82, 1, 2, 82,
# set_local local
DAta[:name_set_local], 83, 1, 2, 83,
# set_local_depth depth, index
DAta[:name_set_local_depth], 84, 2, 3, 84,
# set_stack_local which
DAta[:name_set_stack_local], 85, 1, 2, 85,
# setup_unwind ip, type
DAta[:name_setup_unwind], 86, 2, 3, 86,
# shift_array 
DAta[:name_shift_array], 87, 0, 1, 87,
# store_my_field index
DAta[:name_store_my_field], 88, 1, 2, 88,
# string_append 
DAta[:name_string_append], 89, 0, 1, 89,
# string_build count
DAta[:name_string_build], 90, 1, 2, 90,
# string_dup 
DAta[:name_string_dup], 91, 0, 1, 91,
# swap 
DAta[:name_swap], 92, 0, 1, 92,
# unwind ip
DAta[:name_unwind], 93, 1, 2, 93,
# yield_debugger 
DAta[:name_yield_debugger], 94, 0, 1, 94,
# yield_splat count
DAta[:name_yield_splat], 95, 1, 2, 95,
# yield_stack count
DAta[:name_yield_stack], 96, 1, 2, 96,
# zsuper literal
DAta[:name_zsuper], 97, 1, 2, 97,
# push_file 
DAta[:name_push_file], 98, 0, 1, 98,
# p_any r0
DAta[:name_p_any], 99, 1, 2, 99,
# p_call ip
DAta[:name_p_call], 100, 1, 2, 100,
# p_char chr
DAta[:name_p_char], 101, 1, 2, 101,
# p_char_set chr_set
DAta[:name_p_char_set], 102, 1, 2, 102,
# p_choice ip, r0
DAta[:name_p_choice], 103, 2, 3, 103,
# p_commit ip
DAta[:name_p_commit], 104, 1, 2, 104,
# p_commit_back ip
DAta[:name_p_commit_back], 105, 1, 2, 105,
# p_commit_partial ip
DAta[:name_p_commit_partial], 106, 1, 2, 106,
# p_end 
DAta[:name_p_end], 107, 0, 1, 107,
# p_fail 
DAta[:name_p_fail], 108, 0, 1, 108,
# p_fail_twice 
DAta[:name_p_fail_twice], 109, 0, 1, 109,
# p_jump ip
DAta[:name_p_jump], 110, 1, 2, 110,
# p_return 
DAta[:name_p_return], 111, 0, 1, 111,
# p_span chr_set
DAta[:name_p_span], 112, 1, 2, 112,
# p_test_any n, ip
DAta[:name_p_test_any], 113, 2, 3, 113,
# p_test_char chr, ip
DAta[:name_p_test_char], 114, 2, 3, 114,
# p_test_char_set chr_set, ip
DAta[:name_p_test_char_set], 115, 2, 3, 115,
# p_init r0, r1
DAta[:name_p_init], 116, 2, 3, 116,
# m_bytes value, r0
DAta[:name_m_bytes], 117, 2, 3, 117,
# m_counter value
DAta[:name_m_counter], 118, 1, 2, 118,
# m_sum value, r0
DAta[:name_m_sum], 119, 2, 3, 119,
# m_value value, r0
DAta[:name_m_value], 120, 2, 3, 120,
# m_time_stamp value, flag
DAta[:name_m_time_stamp], 121, 2, 3, 121,
# m_timer_start timer
DAta[:name_m_timer_start], 122, 1, 2, 122,
# m_timer_stop ip, flag
DAta[:name_m_timer_stop], 123, 2, 3, 123,
# b_if_serial r0, r1, ip
DAta[:name_b_if_serial], 124, 3, 4, 124,
# b_if_int r0, r1, ip
DAta[:name_b_if_int], 125, 3, 4, 125,
# b_if r0, ip
DAta[:name_b_if], 126, 2, 3, 126,
# r_load_local r0, local
DAta[:name_r_load_local], 127, 2, 3, 127,
# r_store_local r0, local
DAta[:name_r_store_local], 128, 2, 3, 128,
# r_load_local_depth r0, local, depth
DAta[:name_r_load_local_depth], 129, 3, 4, 129,
# r_store_local_depth r0, local, depth
DAta[:name_r_store_local_depth], 130, 3, 4, 130,
# r_load_stack r0
DAta[:name_r_load_stack], 131, 1, 2, 131,
# r_store_stack r0
DAta[:name_r_store_stack], 132, 1, 2, 132,
# r_load_literal r0, literal
DAta[:name_r_load_literal], 133, 2, 3, 133,
# r_load_int r0, r1
DAta[:name_r_load_int], 134, 2, 3, 134,
# r_store_int r0, r1
DAta[:name_r_store_int], 135, 2, 3, 135,
# r_copy r0, r1
DAta[:name_r_copy], 136, 2, 3, 136,
# n_iadd r0, r1, r2
DAta[:name_n_iadd], 137, 3, 4, 137,
# n_isub r0, r1, r2
DAta[:name_n_isub], 138, 3, 4, 138,
# n_imul r0, r1, r2
DAta[:name_n_imul], 139, 3, 4, 139,
# n_idiv r0, r1, r2
DAta[:name_n_idiv], 140, 3, 4, 140,
# n_iadd_o r0, r1, r2
DAta[:name_n_iadd_o], 141, 3, 4, 141,
# n_isub_o r0, r1, r2
DAta[:name_n_isub_o], 142, 3, 4, 142,
# n_imul_o r0, r1, r2
DAta[:name_n_imul_o], 143, 3, 4, 143,
# n_idiv_o r0, r1, r2
DAta[:name_n_idiv_o], 144, 3, 4, 144,
# n_ieq r0, r1, r2
DAta[:name_n_ieq], 145, 3, 4, 145,
# n_ine r0, r1, r2
DAta[:name_n_ine], 146, 3, 4, 146,
# n_ilt r0, r1, r2
DAta[:name_n_ilt], 147, 3, 4, 147,
# n_ile r0, r1, r2
DAta[:name_n_ile], 148, 3, 4, 148,
# n_igt r0, r1, r2
DAta[:name_n_igt], 149, 3, 4, 149,
# n_ige r0, r1, r2
DAta[:name_n_ige], 150, 3, 4, 150,
# n_ipopcnt r0, r1
DAta[:name_n_ipopcnt], 151, 2, 3, 151,
# m_log r0
DAta[:name_m_log], 152, 1, 2, 152,
# m_debug 
DAta[:name_m_debug], 153, 0, 1, 153,
# e_cache_method_p r0, r1, ip
DAta[:name_e_cache_method_p], 154, 3, 4, 154,
# e_cache_function_p r0, r1, ip
DAta[:name_e_cache_function_p], 155, 3, 4, 155,
# e_cache_value_p r0, ip
DAta[:name_e_cache_value_p], 156, 2, 3, 156,
# e_cache_method r0, ip
DAta[:name_e_cache_method], 157, 2, 3, 157,
# e_cache_function r0, ip
DAta[:name_e_cache_function], 158, 2, 3, 158,
# e_cache_value r0, ip
DAta[:name_e_cache_value], 159, 2, 3, 159,
# e_resolve_method r0, r1, ip
DAta[:name_e_resolve_method], 160, 3, 4, 160,
# e_resolve_receiver_method r0, r1, ip
DAta[:name_e_resolve_receiver_method], 161, 3, 4, 161,
# e_resolve_function r0, r1, ip
DAta[:name_e_resolve_function], 162, 3, 4, 162,
# e_resolve_scope_constant r0, ip
DAta[:name_e_resolve_scope_constant], 163, 2, 3, 163,
# e_resolve_path_constant r0, ip
DAta[:name_e_resolve_path_constant], 164, 2, 3, 164,
# e_signature r0
DAta[:name_e_signature], 165, 1, 2, 165,
# e_check_signature r0, r1
DAta[:name_e_check_signature], 166, 2, 3, 166,
# e_invoke_method r0, r1
DAta[:name_e_invoke_method], 167, 2, 3, 167,
# e_invoke_function r0, r1
DAta[:name_e_invoke_function], 168, 2, 3, 168,
# a_instance r0, r1
DAta[:name_a_instance], 169, 2, 3, 169,
# a_kind r0, r1
DAta[:name_a_kind], 170, 2, 3, 170,
# a_method r0, r1
DAta[:name_a_method], 171, 2, 3, 171,
# a_receiver_method r0, r1
DAta[:name_a_receiver_method], 172, 2, 3, 172,
# a_type r0, r1
DAta[:name_a_type], 173, 2, 3, 173,
# a_function r0, r1
DAta[:name_a_function], 174, 2, 3, 174,
# a_equal r0, r1
DAta[:name_a_equal], 175, 2, 3, 175,
# a_not_equal r0, r1
DAta[:name_a_not_equal], 176, 2, 3, 176,
# a_less r0, r1
DAta[:name_a_less], 177, 2, 3, 177,
# a_less_equal r0, r1
DAta[:name_a_less_equal], 178, 2, 3, 178,
# a_greater r0, r1
DAta[:name_a_greater], 179, 2, 3, 179,
# a_greater_equal r0, r1
DAta[:name_a_greater_equal], 180, 2, 3, 180,
# goto_past location
DAta[:name_goto_past], 181, 1, 2, 181,
# goto_future location
DAta[:name_goto_future], 182, 1, 2, 182,
# r_load_0 r0
DAta[:name_r_load_0], 183, 1, 2, 183,
# r_load_1 r0
DAta[:name_r_load_1], 184, 1, 2, 184,
# r_load_nil r0, r1
DAta[:name_r_load_nil], 185, 2, 3, 185,
# r_load_false r0
DAta[:name_r_load_false], 186, 1, 2, 186,
# r_load_true r0
DAta[:name_r_load_true], 187, 1, 2, 187,
# call_send literal, count
DAta[:name_call_send], 188, 2, 3, 188,
# call literal, count
DAta[:name_call], 189, 2, 3, 189,
# call_0 literal
DAta[:name_call_0], 190, 1, 2, 190,
# push_tagged_nil nil
DAta[:name_push_tagged_nil], 191, 1, 2, 191,
]

# ========== Rubinius application code ================

  # Rbx program opcodes loading
  # for now it's implemented by hand
  # 
  # This is the iterative Fibonacci code
  #   # def fibi(n)
  #     #   return n if n < 2
  #     #   i = 2
  #     #   a = 1
  #     #   b = 1
  #     #   while i < n
  #     #     t = a
  #     #     a += b
  #     #     b = t
  #     #     i += 1
  #     #   end
  #     #   a
  #     # end
  DAta.current_address = 8192

  DAta[:rbx_bytecode] = [
    184, #  0. r_load_1 r1
      1, #  1.
    127, #  2. r_load_local r0, 0
      0, #  3
      0, #  4
    134, #  5. r_load_int r2, r0
      2, #  6
      0, #  7
         #    # n <= 1
    148, #  8. n_ile r3, r2, r1
      3, # 9
      2, # 10
      1, # 11
    126, # 12 b_if r3, done (ip = 49)
      3, # 13
     49, # 14
         #    # a = 1, r0
    184, # 15 r_load_1 r0
      0, # 16.
         #    # b = 1, r3
    184, # 17. r_load_1 r3
      3, # 18.
         #    # i = 2, r4
    137, # 19. n_iadd r4, r0, r0
      4, # 20
      0, # 21
      0, # 22
         #    top.set!
         #    # while i < n, r4 >= r2
    150, # 23. n_ige r5, r4, r2
      5, # 24
      4, # 25
      2, # 26
    126, # 27. b_if r5, int (ip = 46)
      5, # 28
     46, # 29
         #    body.set!
         #    # t = a, r6
    136, # 30. r_copy r6, r0
      6, # 31
      0, # 32
         #    # a += b
    137, # 33. n_iadd r0, r0, r3
      0, # 34
      0, # 35
      3, # 36
         #    # b = t
    136, # 37. r_copy r3, r6
      3, # 38
      6, # 39
         #    # i += 1
    137, # 40. n_iadd r4, r4, r1
      4, # 41
      4, # 42
      1, # 43
         #    # loop
    181, # 44. goto_past top (ip = 23)
     23, # 45.  
         #    int.set!
    135, # 46. r_store_int r0, r0
      0, # 47
      0, # 48
         #    done.set!
    132, # 49. r_store_stack r0
      0, # 50
     70, # 51. ret 0
      0, # 52
  ]

# This is where heap base starts
# Memory 10024 and beyond
#
# Call Frames are stored here
#
DAta.current_address = 10024
