
require 'open-uri'

# load opcodes definition files
LOCAL_FILE  = '/tmp/opcodes.rb'
OPCODES_URL = 'https://raw.githubusercontent.com/rubinius/rubinius-code/master/lib/rubinius/code/compiler/opcodes.rb'

unless File.exist? LOCAL_FILE
  f = open(OPCODES_URL)
  File.open(LOCAL_FILE,'w') do |fh|
    fh.write(f.read)
  end
end


module Rubinius

  Instruction = Struct.new(:id,:name,:stack,:args,:control_flow)

  class InstructionSet
    @@opcodes = []

    def self.opcode(id,name,options = {})
      @@opcodes << Instruction.new(id, name, options[:stack], options[:args], options[:control_flow])
    end

    def self.find_by_name(name)
      @@opcodes.find {|insn| insn.name == name }
    end

    def self.opcodes
      @@opcodes
    end
  end

end

load '/tmp/opcodes.rb'

# =================================================================


NAME_TMPL = 'Data[:name_%s] << "%s\00"'
INSN_TMPL = 'Data[:name_%s], %d, %d, %d, %d,'
FUNC_TMPL = %q{(func %s (param $state i32) (param $cf i32) (param $opcodes i32)
  (call $not_implemented)
)}

class Integer
  def to_little_endian(byte_count)
    ("%0#{byte_count*2}X" % self).scan(/../).reverse.map {|byte| "\\#{byte}"}.join('')
  end
end

# **WARNING** 
# 1) The code assumes there is no "holes" in the opcode
#    IDs numbering
# 2) Make sure to the list of functions by opcode id because 
#    it is used as a function index in WASM (call_indirect)

# Limit the instructions generation to this subset
#names_subset = [:b_if, :goto, :goto_past, :n_iadd, :n_ile, :n_ilt, :n_ige,
#  :r_copy, :r_load_1, :r_load_int, :r_load_local , :r_store_int,
#  :r_store_stack, :ret]

names_subset = Rubinius::InstructionSet.opcodes.sort_by {|op| op.id }.map(&:name)

name_data = []
names_addr = []
instruction_data = []
declaration_data = []
element_data = []
function_data = []

# Generate instruction names data
names_subset.each do |name|
  name_data << sprintf(NAME_TMPL, name, name)
end

# Round addr to the next 4 bytes aligned location

# Generate instruction data name, id, size, args, function index)
# as well as the WASM function prtotypes
names_subset.each_with_index do |name, idx|
  insn = Rubinius::InstructionSet.find_by_name(name)
  id = insn.id
  arg_count = insn.args.size
  size = arg_count + 1
  func_idx = idx

  function_comment = "# #{insn.name} #{insn.args.join(', ')}"
  instruction_data << function_comment
  instruction_data << sprintf(INSN_TMPL, name, size, id, arg_count, func_idx)

  # generate function prototype
  function_data << function_comment
  function_data << sprintf(FUNC_TMPL, "$#{name}")

end

element_data << "(table #{names_subset.size} funcref)"
element_data << '(elem (i32.const 0)'
element_data << names_subset.map {|s| "$#{s}"}.join(' ')
element_data << ')'

names_subset.each do |name|

end


puts "\n# *** This file is generated by #{File.basename(__FILE__)} ***"
puts %q{
# ========== Rubinius Instruction Set ================'
#
# Instructions
#    -> Instruction names
}
puts name_data.join("\n")
puts %q{
#
#     Instruction Set
#
# An instruction is made of 5 fields
#   - Address of instruction name (i32)
#   - size of the instruction
#   - opcode id
#   - number of arguments
#   - function pointer (actually WASM function index)
#-------
}
puts instruction_data.join("\n")
puts %q{
# *** IMPORTANT NOTE ***
# Functions below must be declared in the exact same order as
# the Intruction Set above so that function index in the WASM
# table match the index in the Instuction set array above
}
puts element_data.join("\n")
puts %q{
# ===================================================
# Instruction functions
#
# $cf and $r? parameters are i32 because they are passed as 
#  indices (eg. 1st call frame is 0, r0 is 0, r1 is 1,...)
# $1, $2 params are 64 bits because they are Ruby values
# (TODO: does this make sense ??)
}
puts function_data.join("\n")
